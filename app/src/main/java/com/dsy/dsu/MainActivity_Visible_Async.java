package com.dsy.dsu;import android.app.Activity;import android.content.ContentValues;import android.content.Context;import android.content.Intent;import android.content.pm.ActivityInfo;import android.database.sqlite.SQLiteCursor;import android.os.Build;import android.os.Bundle;import android.os.VibrationEffect;import android.os.Vibrator;import android.util.Log;import android.view.Gravity;import android.view.LayoutInflater;import android.view.View;import android.view.WindowManager;import android.widget.ProgressBar;import android.widget.TextView;import android.widget.Toast;import androidx.annotation.NonNull;import androidx.appcompat.app.AppCompatActivity;import java.security.InvalidKeyException;import java.security.NoSuchAlgorithmException;import java.text.DateFormat;import java.text.DecimalFormat;import java.text.SimpleDateFormat;import java.util.Calendar;import java.util.Date;import java.util.Locale;import java.util.TimeZone;import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.LinkedBlockingQueue;import java.util.concurrent.TimeUnit;import java.util.concurrent.TimeoutException;import java.util.zip.Inflater;import javax.crypto.NoSuchPaddingException;import io.reactivex.Observable;import io.reactivex.Observer;import io.reactivex.disposables.Disposable;import io.reactivex.schedulers.Schedulers;public class MainActivity_Visible_Async extends AppCompatActivity  {    // TODO: 02.09.2021  синхронимзациия визуальная синхронизация    ProgressBar progressBarСинх;    ///     ProgressBar progressBar3ГоризонтальныйСинхронизации;    //// TextView ТекстВидBarСинх;    ///    Activity КонтекстДляСинхронизацииОбмена;    ///    ////// TODO ВРЕМЯ ДЛЯ МОДИФИКАЦИИ ДАННЫХ    protected   Date ДатаДляИзмененияВерсииДанныхНаАндройде;    ///    TextView textViewТекущийПользовательПРиВизуальнойСинхронизации;    ///////    boolean  АктивитиПослеСинхронизацииЗапускалиИлиНет=false;    Integer ПолученныйПубличныйID=0;    //TODO    CREATE_DATABASE Create_Database_СсылкаНАБазовыйКласс;Activity activity;    String КакойРежимСинхрониазцииПерваяСинхронизациИлиПовторная=new String();    // TODO: 12.10.2021  Ссылка Менеджер Потоков    PUBLIC_CONTENT Class_Engine_SQLГдеНаходитьсяМенеджерПотоков =null;    Integer   ПубличноеIDПолученныйИзСервлетаДляUUID=0;    ///    @Override    protected void onCreate(Bundle savedInstanceState) {        try{            getWindow().addFlags(WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD                    | WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON                    | WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);            // TODO: 15.09.2021 ПРИШЕЛ ПАРАМЕНТ КАКУЮ НУЖНО ЗАПИСТИТЬ СИНХРОНИЗАЦИЮ       Intent     Интент_ПолучаемКакойВидСинхронизацииНадоЗапуститьПерваяСинхронизациИлиПовтроная=getIntent();            Class_Engine_SQLГдеНаходитьсяМенеджерПотоков =new PUBLIC_CONTENT(getApplicationContext());      КакойРежимСинхрониазцииПерваяСинхронизациИлиПовторная =              Интент_ПолучаемКакойВидСинхронизацииНадоЗапуститьПерваяСинхронизациИлиПовтроная.getStringExtra("РежимЗапускаСинхронизации");            ///TODO принудительно устанвливаем редим работы синхронизации            Log.d(this.getClass().getName(), " КакойРежимСинхрониазцииПерваяСинхронизациИлиПовторная "+КакойРежимСинхрониазцииПерваяСинхронизациИлиПовторная);            ////            //TODO            Create_Database_СсылкаНАБазовыйКласс=new CREATE_DATABASE(getApplicationContext());            ///TODO КОНТЕКСТ КОТОРЫЙ ПЕРЕДАЮТ ПО ВСЕЙ СИНХРОНИЗАЦИИИ НА ВСЕ ПРИЛОЖЕНИЕ            КонтекстДляСинхронизацииОбмена=this;            ///////////////////////////////            activity=this;                        ((Activity) КонтекстДляСинхронизацииОбмена).setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LOCKED);                        ((Activity) КонтекстДляСинхронизацииОбмена) .setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);            /////todo данная настрока запрещает при запуке активти подскаваать клавиатуре вверх на компонеты eedittext            getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_HIDDEN);            setContentView(R.layout.activity_main__sinfrozisaziy__prograssbar);            super.onCreate(savedInstanceState);            //////todo настрока экрана            getWindow().getDecorView().setSystemUiVisibility(                    View.SYSTEM_UI_FLAG_LAYOUT_STABLE                            | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION                            | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN                            | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION                            | View.SYSTEM_UI_FLAG_FULLSCREEN                            | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY);            getSupportActionBar().setHomeButtonEnabled(false);            getSupportActionBar().setDisplayHomeAsUpEnabled(false);            getSupportActionBar().setHomeAsUpIndicator(null);            //////todo  конец настрока экрана////todo запрещает поворот экрана            Log.d(this.getClass().getName(), "Сработал  protected void onCreate(Bundle savedInstanceState)  MainActivity_Visible_Async" );            getSupportActionBar().hide(); ///скрывать тул бар            //context=this;            progressBarСинх=(ProgressBar) findViewById(R.id.progressBarСинхронизация); /////КНОПКА ТАБЕЛЬНОГО УЧЕТА            // TODO Auto-generated method stub/*            View view;            LayoutInflater inflater =  (LayoutInflater) getApplicationContext().getSystemService(Context.LAYOUT_INFLATER_SERVICE);            view = inflater.inflate(R.layout.activity_main__sinfrozisaziy__prograssbar,null);          ProgressBar progressBar=  view.findViewById(R.id.progressBar3ГоризонтальныйСинхронизации);*/            /////            progressBar3ГоризонтальныйСинхронизации =(ProgressBar) findViewById(R.id.progressBar3ГоризонтальныйСинхронизации);            ////            ТекстВидBarСинх=(TextView) findViewById(R.id.TextViewДляProgressBarГлавнойСинхронизации); /////КНОПКА ТАБЕЛЬНОГО УЧЕТА////////            textViewТекущийПользовательПРиВизуальнойСинхронизации=(TextView) findViewById(R.id.textViewТекущийПользовательПРиВизуальнойСинхронизации); /////КНОПКА ТАБЕЛЬНОГО УЧЕТА//////TODO ловим поворот экрана  ДЛЯ СИНХРОНИЗАЦИИ            Log.i(this.getClass().getName(), "ДО  ОТРАБОТАННЙ СИНХРОНИЗАЦИИ ВИЗУАЛЬНОЙ doInBackground asyncTaskГлавныйДляСинхронизации ");            ////TODO КОД ЗАПУСКАЕТ ВИЗУАЛЬНУЮ СИНХРОНИЗАЦИЮ            new   Visual_synchronization_Executor().МетодНачалоВизуальнойСинхронизацииИзАктивтиExecutor(КакойРежимСинхрониазцииПерваяСинхронизациИлиПовторная);            Log.i(this.getClass().getName(), " пОСЛЕ ОТРАБОТАННЙ СИНХРОНИЗАЦИИ ВИЗУАЛЬНОЙ asyncTaskГлавныйДляСинхронизации ");        } catch (Exception e) {            //  Block of code to handle errors            e.printStackTrace();            ///метод запись ошибок в таблицу            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());               new   Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }    }/*    private void МетодРегистрацииУстройсвоНАFirebaseAndOneSignal() {        try{            ///            String КлючДляFirebaseNotification="2a1819db-60c8-4ca3-a752-1b6cd9cadfa1";            // TODO: 17.12.2021            new Class_Generation_SendBroadcastReceiver_And_Firebase_OneSignal(getApplicationContext()).                    МетодПовторногоЗапускаFacebaseCloud_And_OndeSignal(КлючДляFirebaseNotification,0);            //TODO ФУТУРЕ ЗАВЕРШАЕМ            Log.d(this.getClass().getName(), "  МетодПовторногоЗапускаFacebaseCloud_And_OndeSignal(КлючДляFirebaseNotification,0); " +                    " РезультатЗаписиНовогоIDОтСервреаOneSignal  " );            //        } catch (Exception e) {            e.printStackTrace();            ///метод запись ошибок в ВсеСтрокиJSONДляВставкиОтСервера            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() +                    " Линия  :" + Thread.currentThread().getStackTrace()[2].getLineNumber());            new   Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(),                    Thread.currentThread().getStackTrace()[2].getMethodName(), Thread.currentThread().getStackTrace()[2].getLineNumber());            ////// начало запись в файл        }    }*/    @Override    protected void onRestart() {        super.onRestart();        Log.e(this.getClass().getName(), "onRestart() " );        try {            /// ////TODO ЗАДЕРЖКА ИТЕРАЦИЯ ДЛЯ СИНРОНИЗАЦИИ В ФОНЕ            TimeUnit.MILLISECONDS.sleep(30);        } catch (InterruptedException e) {            e.printStackTrace();        }    }    @Override    public void onBackPressed()    {        //thats it    }    ///todo визуализаци синхронизации /*   //////TODO метод пребразует цифры из цикла в проценты    private String МетодКоторыйПреобразуетЦифрыТекущейТаблицыВПроценты(int ПроцентыДляВизуализацииИхПриСинхронизации) {        Log.d(this.getClass().getName(), " МетодКоторыйПреобразуетЦифрыТекущейТаблицыВПроценты() ");        String ФиналПроцентыДляВизуализацииИхПриСинхронизации = null;        try{            //TODO считаем проценты от цифры            float ОбщееКоличествоТаблиц = PUBLIC_CONTENT.ОбщееКоличествоТаблиц;            float ФиналПроценты = (ПроцентыДляВизуализацииИхПриСинхронизации / ОбщееКоличествоТаблиц) * 100;            ////            ФиналПроценты = (float) Math.ceil(ФиналПроценты);            ФиналПроцентыДляВизуализацииИхПриСинхронизации = String.valueOf(ФиналПроценты);            ///            Log.d(this.getClass().getName(), "  ФиналПроцентыДляВизуализацииИхПриСинхронизации " + ФиналПроцентыДляВизуализацииИхПриСинхронизации);            DecimalFormat decimalFormat = new DecimalFormat("#.#");            ФиналПроцентыДляВизуализацииИхПриСинхронизации = decimalFormat.format(ФиналПроценты) + " %";            Log.d(this.getClass().getName(), "  ФиналПроцентыДляВизуализацииИхПриСинхронизации " + ФиналПроцентыДляВизуализацииИхПриСинхронизации);            //TODO ПОСЫЛАЕМ ВВЕРХ ПО ПОТОКУ        } catch (Exception e) {            //  Block of code to handle errors            e.printStackTrace();            ///метод запись ошибок в таблицу            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());           new   Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(),this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }        ////////////////////////////////        return ФиналПроцентыДляВизуализацииИхПриСинхронизации;    }*/////todo второй метод ВИЗУАЛЬНО  СИНХРОНИЗАЦИИ  ПРИ ИСПОЛЬЗОВАНИИ FUTURE    ///todo визуализаци синхронизации    public  class Visual_synchronization_Executor {        //TODO конструктопр визуальной синхронизации        public Visual_synchronization_Executor() {            ////TODO ЗАДЕРЖКА ИТЕРАЦИЯ ДЛЯ СИНРОНИЗАЦИИ В ФОНЕ отправка данных            ////                    }        // TODO: 02.09.2021  метод визуальной синхронмизации        void МетодНачалоВизуальнойСинхронизацииИзАктивтиExecutor(String КакойРежимСинхрониазцииПерваяСинхронизациИлиПовторная) {            ////TODO ТУТ СКОРЕЙ ВСЕГО БУДЕТ КОТОРЫЙ БУДЕТ ЗАПУСКАТЬСЯ ОТДЕЛЬНО ВТОРЫМ ШАГОМ ОБНОВЛЕНИЯ            /////TODO ЗАПУСКАМ ОБНОЛВЕНИЕ ДАННЫХ С СЕРВЕРА ПЕРЕРД ЗАПУСКОМ ПРИЛОЖЕНИЯ ВСЕ ПРИЛОЖЕНИЯ ДСУ-1            try{                ////////                ////////////TODO ЗАДЕРЖКА ИТЕРАЦИЯ ДЛЯ СИНРОНИЗАЦИИ В ФОНЕ отправка данных                // TODO: 15.09.2021                // TODO: 15.09.2021  ИЗМЕНИЯЕМ РАБОТУ ЖУРНАЛА БАЗЫ ДАННЫХ   НА -- DELETE   ,  РЕЖИМ ПО УМОЛЧАНИЮ                // TODO: 25.05.2021                //////TODO ДО ПОТОКА КОД                МетодДоНачалаСинхрониазцииExecutor();                ///                ////TODO ЗАПУСКАЕМ  МеханизмУправлениеПотокамиОграничеваемИхУжеСозданными                Class_Engine_SQLГдеНаходитьсяМенеджерПотоков.МенеджерПотоков.submit(()->{                        ////                        Integer РезультатФоновойСинхронизации=0;                        try {                            // TODO: 14.11.2021  ПОВТОРЫЙ ЗАПУСК Facebase and OneSignal  ///  КлючДляFirebaseNotification                            ////TODO ПОСЛЕ ЗАВЕРШЕНИЯ РАБОТЫ В В ПОТОКЕ ЗАПУСКАЕМ ПО ЗАВЕРШЕНИЮ                 РезультатФоновойСинхронизации=           МетодВнутриПотокаСинхронизации(КакойРежимСинхрониазцииПерваяСинхронизациИлиПовторная);//////////////////////                            Log.d(this.getClass().getName(), " PUBLIC_CONTENT.ПубличныйЦифраТекущаяТаблицаДляОБменаДанными "                                    + " ИменаТаблицыОтАндройда.size() " + "  РезультатФоновойСинхронизации "+РезультатФоновойСинхронизации);                            //////TODO Выключем после отработки визуальная синхронихация                            // TODO: 22.12.2021  rEGISTA OENSIGMAL                            //                        } catch (Exception e) {                            e.printStackTrace();                            ///метод запись ошибок в ВсеСтрокиJSONДляВставкиОтСервера                            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() +                                    " Линия  :" + Thread.currentThread().getStackTrace()[2].getLineNumber());                         new   Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(),                                    Thread.currentThread().getStackTrace()[2].getMethodName(), Thread.currentThread().getStackTrace()[2].getLineNumber());                            ////// начало запись в файл                        } finally {                            //////TODO Выключем после отработки визуальная синхронихация                            Class_Engine_SQLГдеНаходитьсяМенеджерПотоков.МенеджерПотоков.poll();                                // TODO: 23.12.2021 после присвоение инициализации ONESIGNAL запускаем далее программу                            МетодПослеПотокаСинхронизации();                            // TODO: 22.12.2021                            Log.d(this.getClass().getName(), " ПОСЛЕ ОТРАБОТКИ ВИЗУАЛЬНОЙ СИНХРОНИЗАЦИИ......"+РезультатФоновойСинхронизации);                        return РезультатФоновойСинхронизации;                    }                });                ///                //////            } catch (Exception e) {                //  Block of code to handle errors                e.printStackTrace();                ///метод запись ошибок в таблицу                Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                        + Thread.currentThread().getStackTrace()[2].getLineNumber());               new   Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                        Thread.currentThread().getStackTrace()[2].getLineNumber());            }        }        ////        // TODO: 15.09.2021 метод изменяет редми работыт базы/*        private void onConfigurationChanged(String РежимРаботыБазыИзмененимПользоватлеем) {            try{                // TODO: 15.09.2021  меняем режим работы базы данных                new CREATE_DATABASE(getApplicationContext()).    МетодЗапускаетРежимРаботыБазыДанных( РежимРаботыБазыИзмененимПользоватлеем.trim());//WAL TRUNCATE DELETE                //////            } catch (Exception e) {                //  Block of code to handle errors                e.printStackTrace();                ///метод запись ошибок в таблицу                Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                        + Thread.currentThread().getStackTrace()[2].getLineNumber());                new   Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                        Thread.currentThread().getStackTrace()[2].getLineNumber());            }        }*/        void МетодДоНачалаСинхрониазцииExecutor() {            try{                ////TODO ВЫКИДЫВАЕМ                ////// TODO ВРЕМЯ ДЛЯ МОДИФИКАЦИИ ДАННЫХ                ДатаДляИзмененияВерсииДанныхНаАндройде = Calendar.getInstance().getTime();                ////TODO КОД КОТОРЫЙ ДО ВСЕХ ASYNCTASKLOADER  0 или 1 таюлицы                    ///TODO ПОСЛЕ УСПЕШНОЙ СИНХРНИЗАЦИИ ОБНУЛЯЕМ ВСЕ ПЕРЕМЕННЫЕ КОТОРЫЕ УЧАСТВОВАЛИ В СИНХРОНИЗАЦИИ                    ///TODO флаг который показывает запускали ли мы уже Активити FaceApp                    ///TODO УСТАНАВЛИВАЕМ ФЛАГ ПРИ АУНТИФИКАЦИИ И МЯ И ПАРОЛЬ  СТАЫИМ ФЛАГ включаем  ОБНОВЛЕНИЕ ПРИ СИНХРОНИЗАЦИИ не первый ЗАПУСК И ИЗА ЭТОГО РАЗРЕШАЕМ СИТЕМЕ И ВСТАВЛЯТЬ ДАННЫ И ОБНОВЛЯТЬ ИХ                    /////TODO ПОСЛЕ  СИНХРОНИЗАЦИЕЙ ОБНУЛЯЕМ КОЛИЧЕСТВО СТРОК JSON ОБЩЕЕ  , ПЕРЕД ПОЛУЧЕНИЕМ НОВОГО ЗНАЧЕНИЯ                    //PUBLIC_CONTENT.СколькоСтрочекJSON=0;                    /////TODO ПОСЛЕ  СИНХРОНИЗАЦИЕЙ синхронизации по всем таблицам обнулем общее количество успешных вставко и обновлений                    ////                 //   PUBLIC_CONTENT.ИменаТаблицыОтАндройда.clear();                    //////                    progressBarСинх.setVisibility(View.VISIBLE);                    /////                    ТекстВидBarСинх.setVisibility(View.VISIBLE);                    /////                    progressBar3ГоризонтальныйСинхронизации.setVisibility(View.VISIBLE);                    ///TODO до начала СИНХРОНИЗАЦИИ УСТАНАВЛИВАЕМ ЗНАЧЕНИЕ КОМПОНЕНТОВ                    ТекстВидBarСинх.setText(""+"0" +" %");/// /    ТекстВидBarСинх.setText("0" + " %");                    /////                    ///TODO до начала СИНХРОНИЗАЦИИ УСТАНАВЛИВАЕМ ЗНАЧЕНИЕ КОМПОНЕНТОВ                    progressBar3ГоризонтальныйСинхронизации.setProgress(0);                    //   .makeText(getApplicationContext(), "onStartLoading() i" + ПубличныйЦифраТекущаяТаблицаДляОБменаДанными,  .LENGTH_LONG).show();                    Log.d(this.getClass().getName(), " onStartLoading() начало метода  ");                    /////                    /////TODO прошел не первый запускт            } catch (Exception e) {                e.printStackTrace();                ///метод запись ошибок в таблицу                Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() +                        " Линия  :" + Thread.currentThread().getStackTrace()[2].getLineNumber());             new   Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(),                         Thread.currentThread().getStackTrace()[2].getMethodName(), Thread.currentThread().getStackTrace()[2].getLineNumber());                ////// начало запись в файл            }        }///////TODO спускаемся в поток        Integer МетодВнутриПотокаСинхронизации(String КакойРежимСинхрониазцииПерваяСинхронизациИлиПовторная) throws NoSuchPaddingException, InterruptedException, ExecutionException, NoSuchAlgorithmException, TimeoutException, InvalidKeyException {            ///////////TODO НАЧИНАЕМ ПРОЦЕСС СИНХРОНИЗАЦИИ В МЕТОДЕ bACKgROUND            ////TODO ВЫКИДЫВАЕМ            Log.d(this.getClass().getName(), " loadInBackground()");            PUBLIC_CONTENT public_contentГлавныхТаблицСинхронизации=new PUBLIC_CONTENT(getApplicationContext());            final int[] ФиналОбщееКоличествоСколькоСтрочекJSON = {0};            final String[] ТекущаяТаблицаДляОБменаДанными = {null};            ////TODO уставналиваем констанку что метод onStart запускалься только один раз            int[] ОбщееКоличествоСколькоСтрочекJSON = new int[1];            //////TODO выводими обратно в UI вставка            Integer      РезультатЗапускВизуальнойСинхронизации=0;            //////            try {                ////TODO КОД КОТОРЫЙ ДО ВСЕХ ASYNCTASKLOADER  0 или 1 таюлицы                // TODO: 29.09.2021  перед началом СИНХРОНИЗАЦИИ ПРОВЕРЯЕМ УСТАНОВКИ СЕТИ ПОЛЬЗОВАТЕЛЯ НА АКТИВТИ НАСТРОЙКИ                 boolean РезультатПроВеркиУстановкиПользователяРежимРаботыСетиСтоитЛиЗапускатьСсинхронизацию=        new  Class_Find_Setting_User_Network(getApplicationContext()).МетодПроветяетКакуюУстановкуВыбралПользовательСети();                //TODO ФУТУРЕ ЗАВЕРШАЕМ                Log.d(this.getClass().getName(), "  РезультатПроВеркиУстановкиПользователяРежимРаботыСети " + РезультатПроВеркиУстановкиПользователяРежимРаботыСетиСтоитЛиЗапускатьСсинхронизацию);                    /////                Boolean РезультатЕслиСвязьСерверомПередНачаломВизуальнойСинхронизции = false;                // TODO: 29.09.2021  если предварительаня установленая пользователм настройка соотвецтвует то начинаем синхрониазцию                 Log.d(this.getClass().getName(), "  РезультатПроВеркиУстановкиПользователяРежимРаботыСети " + РезультатПроВеркиУстановкиПользователяРежимРаботыСетиСтоитЛиЗапускатьСсинхронизацию);                if (РезультатПроВеркиУстановкиПользователяРежимРаботыСетиСтоитЛиЗапускатьСсинхронизацию==true) {// TODO: 16.12.2021 НЕПОСРЕДСТВЕННЫЙ ПИНГ СИСТЕНМ ИНТРЕНАТ НА НАЛИЧЕНИ СВАЗИ С БАЗОЙ SQL SERVER                  /*  РезультатЕслиСвязьСерверомПередНачаломВизуальнойСинхронизции = new Class_Connections_Server(getApplicationContext()).МетодПингаСервераРаботаетИлиНет(getApplicationContext());*/                    //TODO ФУТУРЕ ЗАВЕРШАЕМ                        //TODO ВАЖНО НАЧИНАЕМ СИНХРОНИЗХАЦИЮ  ,, ТОЛЬКО КОГДА ЕСТЬ СВЯЗЬ С ИНТРЕНТОМ С СЕРВЕРОМ ЧЕРЕЗ MOBILE ЛИБО WIFI  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!                        Log.d(this.getClass().getName(), " ПОЛУЧАЕМ  " + public_contentГлавныхТаблицСинхронизации.ИменаТаблицыОтАндройда.size() +                                "  \n" + "    СколькоСтрочекJSON");                        /////                        try {                            LinkedBlockingQueue ЗаполненыеСистемныеТаблицыДЛяСинхронизации = new Class__Generation_Genetal_Tables(getApplicationContext()).                                    МетодЗаполеннияТаблицДЛяРаботыиСинхрониазции();                            //TODO ФУТУРЕ ЗАВЕРШАЕМ                            Log.d(this.getClass().getName(), "  ЗаполненыеСистемныеТаблицыДЛяСинхронизации " + ЗаполненыеСистемныеТаблицыДЛяСинхронизации.size());                            // TODO: 15.08.2021  Получаем JSON  От Сервера                            // TODO: 01.07.2021  ЗАПУСКАЕМ ВИЗУАЛЬНУЮ СИНХРОНИЗИЦИЮ С АКТИВТИ ЧДЕ КРУТИТЬСЯ ПРОГРЕСС БАР                            РезультатЗапускВизуальнойСинхронизации =                                    new Class_Engine_SQL(getApplicationContext()).                                            МетодЗАпускаФоновойСинхронизации(getApplicationContext(),                                                    "СинхронизацияОбщая", false, activity, ЗаполненыеСистемныеТаблицыДЛяСинхронизации,                                                    КакойРежимСинхрониазцииПерваяСинхронизациИлиПовторная, ЗаполненыеСистемныеТаблицыДЛяСинхронизации.size());///СколькоСтрочекJSON  //TODO третить параментр false --указывает что обработка всех таблиц кроме чата                                           /*     new Class_Engine_SQL(getApplication()).                                                МетодЗАпускаСинхронизациивВизуальная(getApplication(),"СинхронизацияДляЧата",false,КонтекстДляСинхронизацииОбмена);  //МетодЗАпускаСинхронизациивФонеТолькоСинхронно   //МетодЗАпускаСинхронизациивФоне                                            ///*/                            Log.d(this.getClass().getName(), " РезультатЗапускВизуальнойСинхронизации  СЛУЖБА запуск визуальной синхрониациии"                                    + РезультатЗапускВизуальнойСинхронизации);                            ///todo публикум название таблицы или цифру его                        } catch (Exception e) {                            //  Block of code to handle errors                            e.printStackTrace();                            ///метод запись ошибок в таблицу                            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                                    + Thread.currentThread().getStackTrace()[2].getLineNumber());                            new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(),                                    this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                                    Thread.currentThread().getStackTrace()[2].getLineNumber());                        }                }                ///todo публикум название таблицы или цифру его            } catch (Exception e) {                //  Block of code to handle errors                e.printStackTrace();                ///метод запись ошибок в таблицу                Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                        + Thread.currentThread().getStackTrace()[2].getLineNumber());               new   Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(),this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                        Thread.currentThread().getStackTrace()[2].getLineNumber());            }return  РезультатЗапускВизуальнойСинхронизации;        }        protected Integer МетодЗАписываетНовуюДатуКогдаКлиентУспешноЗАходилВПрорамму() {            //            Integer Результат_АдаптерДляДобавлениеПолученогоУспешноИмяиПарольДляСемидневнойАунтификации=0;            ///            try{                ///                /////                //вставка имя и пароль для автроризации более 7 днней                ContentValues КонтейнерДляЗаписисВТалицуSuccessПриУспешнойСинхрониазцииПоказываетЧСТоПользовательЗаходил = new ContentValues();                ////                ////НАЧАЛО ВСТКИ И ОЧИСТКИ ДАННЫХ ПО ВСТКАЕ ИМЕНИ  И ПАРОЛЯ ПРИ АУНТИФИКАЦИИ ПОЛЬЗОВАТЕЛЯ БОЛЕЕ 7 ДНЕЙ                Date Дата = Calendar.getInstance().getTime();                DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS", new Locale("ru"));//"yyyy-MM-dd HH:mm:ss.SSS"//"yyyy-MM-dd'T'HH:mm:ss'Z'"                dateFormat.setTimeZone(TimeZone.getTimeZone("Europe/Moscow"));                Log.d(this.getClass().getName(), " ГЛАВНАЯ ДАТА ПРОГРАММЫ ДСУ-1 : " + dateFormat.format(Дата));                String ДатаДляПоказываетУспешнойСинхрониазцииЧтоПользовательЗаходилВпрограмму = dateFormat.format(Дата);                ////                КонтейнерДляЗаписисВТалицуSuccessПриУспешнойСинхрониазцииПоказываетЧСТоПользовательЗаходил.put("date_update", ДатаДляПоказываетУспешнойСинхрониазцииЧтоПользовательЗаходилВпрограмму);                // ID                // TODO: 26.08.2021 НОВЫЙ ВЫЗОВ НОВОГО КЛАСС GRUD - ОПЕРАЦИИ                Class_GRUD_SQL_Operations class_grud_sql_operationsПолучаемНаБазуUUIDфиоПолучаемИзТаблицыФИОИМЯ= new Class_GRUD_SQL_Operations(getApplicationContext());                ///                class_grud_sql_operationsПолучаемНаБазуUUIDфиоПолучаемИзТаблицыФИОИМЯ. concurrentHashMapНаборПараментовSQLBuilder_Для_GRUD_Операций.put("СамFreeSQLКОд",                        " SELECT id  FROM successlogin  ORDER BY date_update DESC ;");                // TODO: 12.10.2021  Ссылка Менеджер Потоков                PUBLIC_CONTENT  Class_Engine_SQLГдеНаходитьсяМенеджерПотоков =new PUBLIC_CONTENT (getApplicationContext());                ///////                SQLiteCursor            Курсор_ПолучаемПубличныйID= (SQLiteCursor) class_grud_sql_operationsПолучаемНаБазуUUIDфиоПолучаемИзТаблицыФИОИМЯ.                        new GetаFreeData(getApplicationContext()).getfreedata(class_grud_sql_operationsПолучаемНаБазуUUIDфиоПолучаемИзТаблицыФИОИМЯ. concurrentHashMapНаборПараментовSQLBuilder_Для_GRUD_Операций,                        Class_Engine_SQLГдеНаходитьсяМенеджерПотоков.МенеджерПотоков                        ,Create_Database_СсылкаНАБазовыйКласс.getССылкаНаСозданнуюБазу());                if(Курсор_ПолучаемПубличныйID.getCount()>0){  //                    Курсор_ПолучаемПубличныйID.moveToFirst();                    ///                    /////                    ПубличноеIDПолученныйИзСервлетаДляUUID=         Курсор_ПолучаемПубличныйID.getInt(0);///                    Log.d(this.getClass().getName(), " ПубличноеIDПолученныйИзСервлетаДляUUID  " + ПубличноеIDПолученныйИзСервлетаДляUUID);                }                Log.d(this.getClass().getName(), " ПубличноеIDПолученныйИзСервлетаДляUUID  " + ПубличноеIDПолученныйИзСервлетаДляUUID);                // TODO: 08.09.2021                if ( ПубличноеIDПолученныйИзСервлетаДляUUID>0) {                    //////             /*       Результат_АдаптерДляДобавлениеПолученогоУспешноИмяиПарольДляСемидневнойАунтификации = ССылкаНаСозданнуюБазу.update("SuccessLogin",                            КонтейнерДляЗаписисВТалицуSuccessПриУспешнойСинхрониазцииПоказываетЧСТоПользовательЗаходил,                            "id=?", new String[]{   PUBLIC_CONTENT.ПубличноеIDПолученныйИзСервлетаДляUUID}); ////вставка данных имя и пароль*/                    // TODO: 07.09.2021   новый код GRUD- операции                    Class_GRUD_SQL_Operations class_grud_sql_operationsЗАписываетНовуюДатуКогдаКлиентУспешноЗАходилВПрорамму = new Class_GRUD_SQL_Operations(getApplicationContext());                    ///TODO ОБНОЛВЕНИЕ                    // TODO: 06.09.2021  ПАРАМЕНТЫ ДЛЯ ОБНОВЛЕНИЯ                    class_grud_sql_operationsЗАписываетНовуюДатуКогдаКлиентУспешноЗАходилВПрорамму.                            concurrentHashMapНаборПараментовSQLBuilder_Для_GRUD_Операций.put("НазваниеОбрабоатываемойТаблицы", "SuccessLogin");                    //                    class_grud_sql_operationsЗАписываетНовуюДатуКогдаКлиентУспешноЗАходилВПрорамму.                            concurrentHashMapНаборПараментовSQLBuilder_Для_GRUD_Операций.put("Флаг_ЧерезКакоеПолеОбновлением", "id");                    ///                    //                    class_grud_sql_operationsЗАписываетНовуюДатуКогдаКлиентУспешноЗАходилВПрорамму.                            concurrentHashMapНаборПараментовSQLBuilder_Для_GRUD_Операций.put("ЗначениеФлагОбновления", ПубличноеIDПолученныйИзСервлетаДляUUID);                    //                    class_grud_sql_operationsЗАписываетНовуюДатуКогдаКлиентУспешноЗАходилВПрорамму.                            concurrentHashMapНаборПараментовSQLBuilder_Для_GRUD_Операций.put("ЗнакФлагОбновления", "=");                    ////TODO КОНТЕЙНЕР ДЛЯ ОБНОВЛЕНИЯ                    class_grud_sql_operationsЗАписываетНовуюДатуКогдаКлиентУспешноЗАходилВПрорамму.                            contentValuesДляSQLBuilder_Для_GRUD_Операций.putAll(КонтейнерДляЗаписисВТалицуSuccessПриУспешнойСинхрониазцииПоказываетЧСТоПользовательЗаходил);                    ///TODO РЕЗУЛЬТАТ ОБНОВЛЕНИЕ ДАННЫХ                    Результат_АдаптерДляДобавлениеПолученогоУспешноИмяиПарольДляСемидневнойАунтификации = 0;                    ////                    Результат_АдаптерДляДобавлениеПолученогоУспешноИмяиПарольДляСемидневнойАунтификации = (Integer) class_grud_sql_operationsЗАписываетНовуюДатуКогдаКлиентУспешноЗАходилВПрорамму.                            new UpdateData(getApplicationContext()).updatedata(class_grud_sql_operationsЗАписываетНовуюДатуКогдаКлиентУспешноЗАходилВПрорамму.concurrentHashMapНаборПараментовSQLBuilder_Для_GRUD_Операций,                            class_grud_sql_operationsЗАписываетНовуюДатуКогдаКлиентУспешноЗАходилВПрорамму.contentValuesДляSQLBuilder_Для_GRUD_Операций,                            Class_Engine_SQLГдеНаходитьсяМенеджерПотоков.МенеджерПотоков,Create_Database_СсылкаНАБазовыйКласс.getССылкаНаСозданнуюБазу());                    Log.d(this.getClass().getName(), " Результат_АдаптерДляДобавлениеПолученогоУспешноИмяиПарольДляСемидневнойАунтификации"                            + Результат_АдаптерДляДобавлениеПолученогоУспешноИмяиПарольДляСемидневнойАунтификации);/*                    //////////////////////////////////////////////////////////////TODO _____old                           ПриписиИзменнийВерсииДанныхДва=new    ();                       ПриписиИзменнийВерсииДанныхДва.setTables("SuccessLogin");                    if (!ССылкаНаСозданнуюБазу.isReadOnly()) {                        ////////                        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {                            Результат_АдаптерДляДобавлениеПолученогоУспешноИмяиПарольДляСемидневнойАунтификации  =             ПриписиИзменнийВерсииДанныхДва.                                    update(ССылкаНаСозданнуюБазу,КонтейнерДляЗаписисВТалицуSuccessПриУспешнойСинхрониазцииПоказываетЧСТоПользовательЗаходил,                                            "id=?", new String[]{   PUBLIC_CONTENT.ПубличноеIDПолученныйИзСервлетаДляUUID});                        }else{                            Результат_АдаптерДляДобавлениеПолученогоУспешноИмяиПарольДляСемидневнойАунтификации  =                                    ССылкаНаСозданнуюБазу.update("SuccessLogin",КонтейнерДляЗаписисВТалицуSuccessПриУспешнойСинхрониазцииПоказываетЧСТоПользовательЗаходил,                                    "id=?", new String[]{   PUBLIC_CONTENT.ПубличноеIDПолученныйИзСервлетаДляUUID});                        }                    }                }*/                    // TODO: 08.09.2021  resultat                    if (Результат_АдаптерДляДобавлениеПолученогоУспешноИмяиПарольДляСемидневнойАунтификации > 0) {                        //                        Log.d(getApplicationContext().getClass().getName(), " Результат_АдаптерДляДобавлениеПолученогоУспешноИмяиПарольДляСемидневнойАунтификации " + "--"                                + Результат_АдаптерДляДобавлениеПолученогоУспешноИмяиПарольДляСемидневнойАунтификации);/////                    } else {                        /////                        Log.d(getApplicationContext().getClass().getName(), " NO Результат_АдаптерДляДобавлениеПолученогоУспешноИмяиПарольДляСемидневнойАунтификации " + "--"                                + Результат_АдаптерДляДобавлениеПолученогоУспешноИмяиПарольДляСемидневнойАунтификации);/////                    }                    /////                }                ///todo публикум название таблицы или цифру его            } catch (Exception e) {                //  Block of code to handle errors                e.printStackTrace();                ///метод запись ошибок в таблицу                Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                        + Thread.currentThread().getStackTrace()[2].getLineNumber());               new   Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(),                 this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                        Thread.currentThread().getStackTrace()[2].getLineNumber());            }            // TODO: 08.09.2021 resultat final            return  Результат_АдаптерДляДобавлениеПолученогоУспешноИмяиПарольДляСемидневнойАунтификации;        }                                                                                                                                ///TODO вычисляем если такая таблиЦА ВНУТРИ БАЗЫ        protected boolean МетодВЫчисляемВсеТаблицыВнутриКлинета(String ТекущаяТаблицаДляОБменаДанными) {            ////            boolean ЕслиТАкаяТаблица = false;            ////            SQLiteCursor КурсорВсехТаблицВнутри=null;            try{                // TODO: 26.08.2021 НОВЫЙ ВЫЗОВ НОВОГО КЛАСС GRUD - ОПЕРАЦИИ           Class_GRUD_SQL_Operations     class_grud_sql_operationsВЫчисляемВсеТаблицыВнутриКлинета=new Class_GRUD_SQL_Operations(getApplicationContext());                ///                class_grud_sql_operationsВЫчисляемВсеТаблицыВнутриКлинета. concurrentHashMapНаборПараментовSQLBuilder_Для_GRUD_Операций.put("НазваниеОбрабоатываемойТаблицы","sqlite_master");                ///////                class_grud_sql_operationsВЫчисляемВсеТаблицыВнутриКлинета. concurrentHashMapНаборПараментовSQLBuilder_Для_GRUD_Операций.put("СтолбцыОбработки","name");                //                class_grud_sql_operationsВЫчисляемВсеТаблицыВнутриКлинета. concurrentHashMapНаборПараментовSQLBuilder_Для_GRUD_Операций.put("ФорматПосика","type = 'table' ");                    ///"_id > ?   AND _id< ?"                    //////             /*       class_grud_sql_operations. concurrentHashMapНаборПараментовSQLBuilder_Для_GRUD_Операций.put("УсловиеПоиска1",finalПолученныйUUID);                    ///                    class_grud_sql_operations. concurrentHashMapНаборПараментовSQLBuilder_Для_GRUD_Операций.put("УсловиеПоиска2","Удаленная");                    ///                    class_grud_sql_operations. concurrentHashMapНаборПараментовSQLBuilder_Для_GRUD_Операций.put("УсловиеПоиска3",МЕсяцДляКурсораТабелей);                    //                    class_grud_sql_operations. concurrentHashMapНаборПараментовSQLBuilder_Для_GRUD_Операций.put("УсловиеПоиска4",ГодДляКурсораТабелей);////УсловиеПоискаv4,........УсловиеПоискаv5 .......*/                ////TODO другие поля                ///classGrudSqlOperations. concurrentHashMapНаборПараментовSQLBuilder_Для_GRUD_Операций.put("ПоляГрупировки",null);                ////                //class_grud_sql_operations. concurrentHashMapНаборПараментовSQLBuilder_Для_GRUD_Операций.put("УсловиеГрупировки",null);                ////               // class_grud_sql_operationsПолучениеИмяСистемы. concurrentHashMapНаборПараментовSQLBuilder_Для_GRUD_Операций.put("УсловиеСортировки","date_update");                ////                /// class_grud_sql_operations. concurrentHashMapНаборПараментовSQLBuilder_Для_GRUD_Операций.put("УсловиеЛимита","1");                ////                // TODO: 27.08.2021  ПОЛУЧЕНИЕ ДАННЫХ ОТ КЛАССА GRUD-ОПЕРАЦИИ                КурсорВсехТаблицВнутри=null;                КурсорВсехТаблицВнутри= (SQLiteCursor)  new Class_GRUD_SQL_Operations(getApplicationContext()).                        new GetData(getApplicationContext()).getdata(class_grud_sql_operationsВЫчисляемВсеТаблицыВнутриКлинета. concurrentHashMapНаборПараментовSQLBuilder_Для_GRUD_Операций,                        Class_Engine_SQLГдеНаходитьсяМенеджерПотоков.МенеджерПотоков                        ,Create_Database_СсылкаНАБазовыйКласс.getССылкаНаСозданнуюБазу());                Log.d(this.getClass().getName(), "GetData "  +КурсорВсехТаблицВнутри);    /*            // TODO: 08.09.2021 ____old                /////              КурсорВсехТаблицВнутри=ССылкаНаСозданнуюБазу.rawQuery("SELECT name FROM sqlite_master WHERE type = 'table'",null);*/                // TODO: 08.09.2021 resultat                if(КурсорВсехТаблицВнутри.getCount()>0) {                    КурсорВсехТаблицВнутри.moveToFirst();                    Log.d(this.getClass().getName(), "  КурсорВсехТаблицВнутри."  +  КурсорВсехТаблицВнутри.getCount());                    // TODO: 08.09.2021  цикл                    do {                        ////                        if (ТекущаяТаблицаДляОБменаДанными.equals(КурсорВсехТаблицВнутри.getString(0))) {                            Log.d(this.getClass().getName(), "  ТекущаяТаблицаДляОБменаДанными." + ТекущаяТаблицаДляОБменаДанными +                                    "  КурсорВсехТаблицВнутри.getString(0)) " + КурсорВсехТаблицВнутри.getString(0));                            ЕслиТАкаяТаблица = true;                            break;                        }                        Log.d(this.getClass().getName(), "  ТекущаяТаблицаДляОБменаДанными." + ТекущаяТаблицаДляОБменаДанными +                                "  КурсорВсехТаблицВнутри.getString(0)) " + КурсорВсехТаблицВнутри.getString(0));                    }while(КурсорВсехТаблицВнутри.moveToNext());                    ////////                    КурсорВсехТаблицВнутри.close();                }else{                    Log.d(this.getClass().getName(), "  КурсорВсехТаблицВнутри."  +  КурсорВсехТаблицВнутри.getCount());                    //////                    ЕслиТАкаяТаблица=false;                }                ///todo публикум название таблицы или цифру его            } catch (Exception e) {                //  Block of code to handle errors                e.printStackTrace();                ///метод запись ошибок в таблицу                Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                        + Thread.currentThread().getStackTrace()[2].getLineNumber());               new   Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(),               this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                        Thread.currentThread().getStackTrace()[2].getLineNumber());            }////            return ЕслиТАкаяТаблица;        }        ///TODO МЕТОД ПОСЛЕ ЗАВЕРШЕНИЯ РАБОТЫ В НИЖНЕМ ПОТОКЕ        public void МетодПослеПотокаСинхронизации() throws ExecutionException, InterruptedException {            Log.d(this.getClass().getName(), " КОНЕЦ синхронизация  onStopLoading()  ");            try{                Class_GRUD_SQL_Operations class_grud_sql_operationsПолучаемНаБазуUUIDфиоПолучаемИзТаблицыФИОИМЯ= new Class_GRUD_SQL_Operations(getApplicationContext());                ///////                PUBLIC_CONTENT  Class_Engine_SQLГдеНаходитьсяМенеджерПотоков =new PUBLIC_CONTENT(getApplicationContext());                ///// TODO  ПОСЛЕ ВИЗУАЛЬНОЙ СИНХРОНИЗАЦИИ ЗАПУСКАЕМ ЕЩЕ РАЗ СИНХРОНИЗАЦИЮ В ФОНЕ НА ВСЯКИЙ СЛУЧАЙ                Log.d(this.getClass().getName(), " stopLoading() " + " ПубличныйЦифраТекущаяТаблицаДляОБменаДанными " );                ///                final int ЗначениеФинальноеДляГоризонтальногоPrograssbar =1;/////                final int ЗначениеФинальноеДляКруглыйPrograssbar= 1;                final int  ОбщееКоличествоТаблицДляГоризонтальногоPrograssBar = 14;                ////TODO КОГДА СИНХРОНИЗАЦИЯ ЗАКАНЧИВАЕТЬСЯ МЫ ДАННЫМИ МЕТОДОМ ОБНУДЯЕМ ПЕРЕМЕННЫЕ И И ЗАПУВСКАМ АКТИВТИ FACEAPP                        //  .makeText(getApplicationContext(), " stopLoading() " + 100,  .LENGTH_LONG).show();                        Log.d(this.getClass().getName(), " stopLoading()  100 " + "  ЗначениеФинальноеДляКруглыйPrograssbar "                                +ЗначениеФинальноеДляКруглыйPrograssbar +" ЗначениеФинальноеДляГоризонтальногоPrograssbar " +ЗначениеФинальноеДляГоризонтальногоPrograssbar);                        //TODO ДАННЫЙ КОД НАЧИНАЙ РАБОТАТЬ ПОСЛЕ СИНХРОНИЗАЦИИ                            ТекстВидBarСинх.setText("100 %");                        ////// TODO Горизонтальный PrograssBar                        if (ОбщееКоличествоТаблицДляГоризонтальногоPrograssBar>0) {                            progressBar3ГоризонтальныйСинхронизации.setMax(ОбщееКоличествоТаблицДляГоризонтальногоPrograssBar);                            /////TODO ПОСЛЕ СИНХРОНИЗАЦИИ УСТАНАВЛИВАЕ НА ГОРИЗОНТАЛЬНЫЙ PROGRASBAR ЗНАЧЕНИЯ                            progressBar3ГоризонтальныйСинхронизации.setProgress(ОбщееКоличествоТаблицДляГоризонтальногоPrograssBar);                        }else{                            progressBar3ГоризонтальныйСинхронизации.setMax(100);                            /////TODO ПОСЛЕ СИНХРОНИЗАЦИИ УСТАНАВЛИВАЕ НА ГОРИЗОНТАЛЬНЫЙ PROGRASBAR ЗНАЧЕНИЯ                            progressBar3ГоризонтальныйСинхронизации.setProgress(100);                        }                        ////                        progressBar3ГоризонтальныйСинхронизации.requestFocus();                        ///TODO ПОСЛЕ УСПЕШНОЙ СИНХРНИЗАЦИИ ОБНУЛЯЕМ ВСЕ ПЕРЕМЕННЫЕ КОТОРЫЕ УЧАСТВОВАЛИ В СИНХРОНИЗАЦИИ                        ///TODO УСТАНАВЛИВАЕМ ФЛАГ ПРИ АУНТИФИКАЦИИ И МЯ И ПАРОЛЬ  СТАЫИМ ФЛАГ включаем  ОБНОВЛЕНИЕ ПРИ СИНХРОНИЗАЦИИ не первый ЗАПУСК И ИЗА ЭТОГО РАЗРЕШАЕМ СИТЕМЕ И ВСТАВЛЯТЬ ДАННЫ И ОБНОВЛЯТЬ ИХ                Log.d(this.getClass().getName(), " ПолученныйПубличныйID  " + ПолученныйПубличныйID);                if (ПолученныйПубличныйID==0) {                    // TODO: 26.08.2021 НОВЫЙ ВЫЗОВ НОВОГО КЛАСС GRUD - ОПЕРАЦИИ                    ///                    class_grud_sql_operationsПолучаемНаБазуUUIDфиоПолучаемИзТаблицыФИОИМЯ. concurrentHashMapНаборПараментовSQLBuilder_Для_GRUD_Операций.put("СамFreeSQLКОд",                            " SELECT id  FROM successlogin  ORDER BY date_update DESC ;");                    // TODO: 12.10.2021  Ссылка Менеджер Потоков                    SQLiteCursor            Курсор_ПолучаемПубличныйID= null;                    ///////                        Курсор_ПолучаемПубличныйID= (SQLiteCursor) class_grud_sql_operationsПолучаемНаБазуUUIDфиоПолучаемИзТаблицыФИОИМЯ.                            new GetаFreeData(getApplicationContext()).getfreedata(class_grud_sql_operationsПолучаемНаБазуUUIDфиоПолучаемИзТаблицыФИОИМЯ.                                    concurrentHashMapНаборПараментовSQLBuilder_Для_GRUD_Операций,                            Class_Engine_SQLГдеНаходитьсяМенеджерПотоков.МенеджерПотоков,Class_Engine_SQLГдеНаходитьсяМенеджерПотоков.getССылкаНаСозданнуюБазу());                    if(Курсор_ПолучаемПубличныйID.getCount()>0){    ////                        Курсор_ПолучаемПубличныйID.moveToFirst();                        /////                        ПолученныйПубличныйID=         Курсор_ПолучаемПубличныйID.getInt(0);    ///                        Log.d(this.getClass().getName(), " ПолученныйПубличныйID  " + ПолученныйПубличныйID);                    }                    ///TODO УСТАНАВЛИВАЕМ ФЛАГ ПРИ АУНТИФИКАЦИИ И МЯ И ПАРОЛЬ  СТАЫИМ ФЛАГ ОТКЛЮЧИТЬ ОБНОВЛЕНИЕ ПРИ СИНХРОНИЗАЦИИ false по умолчанию проверяем                    //     PUBLIC_CONTENT.ФлагПриПервомЗапускеОграничитьОперациюТолькоВставка=true; ///после успещной синхрониации устанавлием флаг на отркытие обновления TRUE                }                /////TODO устанавливаем флаг чьто иы уже запускали FAceAPP                        АктивитиПослеСинхронизацииЗапускалиИлиНет=true;                        //////////                //TODO  ПРОВЕРЯЕМ ТЕКУЩИЙ ПОЛЬЗОВАТЕЛЬ МОЖНО РАБОТАТЬ ИЛИ ОН ЗАБЛОКИРОВАН                ///                class_grud_sql_operationsПолучаемНаБазуUUIDфиоПолучаемИзТаблицыФИОИМЯ=new Class_GRUD_SQL_Operations(getApplicationContext());                // TODO: 26.08.2021 НОВЫЙ ВЫЗОВ НОВОГО КЛАСС GRUD - ОПЕРАЦИИ                ///                class_grud_sql_operationsПолучаемНаБазуUUIDфиоПолучаемИзТаблицыФИОИМЯ. concurrentHashMapНаборПараментовSQLBuilder_Для_GRUD_Операций.put("СамFreeSQLКОд",                        " SELECT locked  FROM chat_users  WHERE _id= '"+ПолученныйПубличныйID+"'  ORDER BY date_update DESC ;");                // TODO: 12.10.2021  Ссылка Менеджер Потоков                Integer ПолученныйСтатусТекущегоПользователя=0;                SQLiteCursor            Курсор_ПолучаемСтатусТекущагоПользователяНеЗаблокированЛиОнАдминистатором=null;                ///////                       Курсор_ПолучаемСтатусТекущагоПользователяНеЗаблокированЛиОнАдминистатором=                        (SQLiteCursor) class_grud_sql_operationsПолучаемНаБазуUUIDфиоПолучаемИзТаблицыФИОИМЯ.                        new GetаFreeData(getApplicationContext()).getfreedata(class_grud_sql_operationsПолучаемНаБазуUUIDфиоПолучаемИзТаблицыФИОИМЯ.                                        concurrentHashMapНаборПараментовSQLBuilder_Для_GRUD_Операций,                        Class_Engine_SQLГдеНаходитьсяМенеджерПотоков.МенеджерПотоков,                                Create_Database_СсылкаНАБазовыйКласс.getССылкаНаСозданнуюБазу());                Log.d(this.getClass().getName(), " Курсор_ПолучаемСтатусТекущагоПользователяНеЗаблокированЛиОнАдминистатором.getCount() " +Курсор_ПолучаемСтатусТекущагоПользователяНеЗаблокированЛиОнАдминистатором.getCount());                if(Курсор_ПолучаемСтатусТекущагоПользователяНеЗаблокированЛиОнАдминистатором.getCount()>0) {//////                    Курсор_ПолучаемСтатусТекущагоПользователяНеЗаблокированЛиОнАдминистатором.moveToFirst();                    Integer ИндексНазваниестоликаБлокироваки=Курсор_ПолучаемСтатусТекущагоПользователяНеЗаблокированЛиОнАдминистатором.getColumnIndex("locked") ;                    /////                    ПолученныйСтатусТекущегоПользователя = Курсор_ПолучаемСтатусТекущагоПользователяНеЗаблокированЛиОнАдминистатором.getInt(ИндексНазваниестоликаБлокироваки);                    Log.d(this.getClass().getName(), " ПолученныйСтатусТекущегоПользователя " + ПолученныйСтатусТекущегоПользователя);                    // TODO: 14.10.2021                    if(ПолученныйСтатусТекущегоПользователя==null){                        //                        ПолученныйСтатусТекущегоПользователя=0;                    }                    // TODO: 14.10.2021 ЕСЛИ НОЛЬ 0  ТО НЕ ЗАБЛОКИРОВАН                    if (ПолученныйСтатусТекущегоПользователя == 0) {                        ////TODO ВЫКИДЫВАЕМ ОБРАТНО В UI ИЗ ПОТОКА BACKCALLS В ГОРИЗОНТАЛЬНОМ PROGRASSBAR УВЕЛИЧЕНИЯ ПОЛОСКИ НА ОДНУ ТАБЛИЦУ                        Integer РезультатПоказываетЧтоПользовательУспешноЗАходл = МетодЗАписываетНовуюДатуКогдаКлиентУспешноЗАходилВПрорамму();                        Log.d(this.getClass().getName(), "  РезультатПоказываетЧтоПользовательУспешноЗАходл  " + РезультатПоказываетЧтоПользовательУспешноЗАходл);                        String ПолученыйТекущееИмяПользователя = new MODEL_synchronized(getApplicationContext()).МетодПолучениеИмяСистемыДляСменыПользователя(getApplicationContext());                        Log.d(this.getClass().getName(), "  ПолученыйТекущееИмяПользователя  " + ПолученыйТекущееИмяПользователя);                        textViewТекущийПользовательПРиВизуальнойСинхронизации.setText("пользователь: " + ПолученыйТекущееИмяПользователя.toUpperCase());                        ////                        Log.d(this.getClass().getName(), " PUBLIC_CONTENT.ПубличныйЦифраТекущаяТаблицаДляОБменаДанными "                                + " ПолученныйСтатусТекущегоПользователя " + ПолученныйСтатусТекущегоПользователя);                        //////////////////////////////////////                        // TODO: 15.09.2021  ИЗМЕНИЯЕМ РАБОТУ ЖУРНАЛА БАЗЫ ДАННЫХ   НА -- WAL                        //////TODO запускаем после синхронизации                        Log.d(this.getClass().getName(), " ПолученныйСтатусТекущегоПользователя " + ПолученныйСтатусТекущегоПользователя);                        Vibrator v2 = (Vibrator) getApplicationContext().getSystemService(Context.VIBRATOR_SERVICE);                        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {                            v2.vibrate(VibrationEffect.createOneShot(100, VibrationEffect.DEFAULT_AMPLITUDE));                        } else {                            //deprecated in API 26                            v2.vibrate(100);                        }                        //////////////////                        Intent ИнтентДляЗапускаДляВизуализацииСинхронизации = new Intent(КонтекстДляСинхронизацииОбмена, MainActivity_Face_App.class);                        ИнтентДляЗапускаДляВизуализацииСинхронизации.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_SINGLE_TOP );                        КонтекстДляСинхронизацииОбмена.startActivity(ИнтентДляЗапускаДляВизуализацииСинхронизации);                        КонтекстДляСинхронизацииОбмена.finish();                        Log.d(this.getClass().getName(), " ПолученныйСтатусТекущегоПользователя " + ПолученныйСтатусТекущегоПользователя);                        // TODO: ТЕКУЩИЙ ПОЛЬЗОВАТЕЛЬ ЗАБЛОКИРОВАН                    } else if  (ПолученныйСтатусТекущегоПользователя == 1) {                        Log.d(this.getClass().getName(), " ПолученныйСтатусТекущегоПользователя " + ПолученныйСтатусТекущегоПользователя);                        // TODO: 14.10.2021  когда пользователь временно заблокирован                        //////////////////                        Intent ИнтентДляЗапускаДляВизуализацииСинхронизации = new Intent(КонтекстДляСинхронизацииОбмена, MainActivity_Tabels_Users_And_Passwords.class);                        ИнтентДляЗапускаДляВизуализацииСинхронизации.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_SINGLE_TOP);                        КонтекстДляСинхронизацииОбмена.startActivity(ИнтентДляЗапускаДляВизуализацииСинхронизации);                        КонтекстДляСинхронизацииОбмена.finish();                        Log.e(this.getClass().getName(), " Вы заблокированны обратитесь к Администатору ПО !!! ");                      Toast.makeText(getApplicationContext(), "  Вы заблокированны обратитесь к Администатору ПО !!! " , Toast.LENGTH_LONG).show();                    }                    ///TODO   конец ОБНУЛЕНИЯ ПЕРЕМЕННЫХ ПОСЛЕ УСПЕШНОЙ СИНХРНИЗАЦИИ ОБНУЛЯЕМ ВСЕ ПЕРЕМЕННЫЕ КОТОРЫЕ УЧАСТВОВАЛИ В СИНХРОНИЗАЦИИ                }else{  // TODO: 14.10.2021  когда пользователь временно заблокирован                    //////////////////                    Intent ИнтентДляЗапускаДляВизуализацииСинхронизации = new Intent(КонтекстДляСинхронизацииОбмена, MainActivity_Tabels_Users_And_Passwords.class);                    ИнтентДляЗапускаДляВизуализацииСинхронизации.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_SINGLE_TOP);                    КонтекстДляСинхронизацииОбмена.startActivity(ИнтентДляЗапускаДляВизуализацииСинхронизации);                    КонтекстДляСинхронизацииОбмена.finish();                    Log.e(this.getClass().getName(), " Не достаточно данных чтобы начать работать обратитесь к Администатору ПО !!!  ");                    Toast.makeText(getApplicationContext(), "  Вы заблокированны обратитесь к Администатору ПО !!! " , Toast.LENGTH_LONG).show();                }                /////TODO после синхронизации обнуялем*/            } catch (Exception e) {                //  Block of code to handle errors                e.printStackTrace();                ///метод запись ошибок в таблицу                Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                        + Thread.currentThread().getStackTrace()[2].getLineNumber());               new   Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(),               this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                        Thread.currentThread().getStackTrace()[2].getLineNumber());            }        }    }}//////ТУТ БУДЕТ ЗАПИСЫВАТЬСЯ УСПЕШНОЕ ОБНЛВДЕНИ И ВСТАВКИ ДАННЫХ НА СЕРВЕРЕ ДЛЯ КЛИЕНТА